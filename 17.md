# Context
```jsx
// src/count/count-context.js
import * as React from 'react'const CountContext = React.createContext()
function useCount() {  
    const context = React.useContext(CountContext)
    if (!context) {    
        throw new Error(`useCount must be used within a CountProvider`)
    }
    return context
}

function CountProvider(props) {
  const [count, setCount] = React.useState(0)
  const value = React.useMemo(() => [count, setCount], [count])
  return <CountContext.Provider value={value} {...props} />
}

export {CountProvider, useCount}

// src/count/page.js
import * as React from 'react'
import {CountProvider, useCount} from './count-context'

function Counter() {7  const [count, setCount] = useCount()
  const increment = () => setCount(c => c + 1)
  return <button onClick={increment}>{count}</button>
}

function CountDisplay() {
  const [count] = useCount()
  return <div>The current counter count is {count}</div>
}

function CountPage() {
  return (
    <div>
      <CountProvider>
        <CountDisplay />
        <Counter />
      </CountProvider>
    </div>
  )
}
```

Not everything in your application needs to be in a single state object. Keep things logically separated (user settings does not necessarily have to be in the same context as notifications). You will have multiple providers with this approach.
Not all of your context needs to be globally accessible! Keep state as close to where it's needed as possib